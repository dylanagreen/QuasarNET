#!/usr/bin/env python

import numpy as np
from quasarnet import io
import fitsio
import sys

import argparse

parser=argparse.ArgumentParser()
parser.add_argument('--spplates',type=str, nargs="+", required=True)
parser.add_argument('--spall',type=str, required=True)
parser.add_argument('--sdrq',type=str, required=False, default=None)
parser.add_argument('--out',type=str, required=True)
parser.add_argument('--single-exposures', action='store_true', default=False,
                    required=False)
parser.add_argument('--spcframes',type=str, nargs="+", required=False)

args=parser.parse_args()

## Construct a dictionary (plate, mjd, fiberid) => thing_id
print('INFO: reading spall')
tids_spall, thid_db = io.read_spall(args.spall)
pmf_spall = list(thid_db.keys())
print('INFO: done')

## If we have an sdrq, filter the tids from spall by those in sdrq.
if args.sdrq is not None:
    print('INFO: reading sdrq')
    sdrq = fitsio.FITS(args.sdrq)
    tids_sdrq = sdrq[1]['THING_ID'][:]
    print('INFO: done')
    w = np.in1d(tids_spall, tids_sdrq) & (tids_spall>0)
## Otherwise, filter by hardcoded targeting bits.
else:
    print('getting quasars from target bits')
    tb = {'BOSS_TARGET1':[10,11,12,13,14,15,16,17,18,19,40,41,42,43,44],
        'EBOSS_TARGET0':[10,11,12,13,14,15,16,17,18,20,22,30,31,33,34,35,40],
        'EBOSS_TARGET1':[9,10,11,12,13,14,15,16,17,18,30,31],
        'EBOSS_TARGET2':[0,2,4,20,21,23,24,25,26,27,31,32,33,34,50,51,
            52,53,54,55,56,57,58,59,60,61,62],
        'ANCILLARY_TARGET1':[6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,22,
            23,24,25,26,27,28,29,30,31,50,51,52,53,54,55,58,59],
        'ANCILLARY_TARGET2':[0,1,2,3,4,5,7,8,9,10,13,14,15,24,
            25,26,27,31,32,33,53,54,55,56]
        }

    # Open the spall file to extract further information.
    spall = fitsio.FITS(args.spall)
    plate_quality = spall[1]['PLATEQUALITY'][:]

    # Cycle through each targeting bit to build a mask including all bits.
    wqso = np.zeros(len(tids_spall), dtype=bool)
    for kw,val in tb.items():
        mask = sum([2**b for b in val])
        wqso_kw = (mask & spall[1][kw][:])>0
        print('INFO: found {} quasar targets with target bits {}'.format(wqso_kw.sum(),kw))
        wqso |= wqso_kw
    print('INFO: found {} quasar targets'.format(wqso.sum()))

    # Impose that the plate_quality must be 'good'
    #wqso &= (plate_quality == 'good')
    # This doesn't seem to worrk any more for some reason.
    print(plate_quality[:5])
    print(plate_quality.dtype)
    wqso &= ((plate_quality == b'good') | (plate_quality == 'good'))
    print('INFO: after rejecting BAD plates, {} remain'.format(wqso.sum()))

    spall.close()

## Construct a dictionary describing the fiberids that were used in each
## (plate,mjd) pair for objects in our spall file.
plate_mjd = {}
for i,(p,m,f) in enumerate(np.array(pmf_spall)[wqso]):
    sys.stderr.write('\rINFO: populating dict: {:.1%}'.format(i/len(pmf_spall)))
    k = (p,m)
    if not k in plate_mjd:
        plate_mjd[k] = []
    plate_mjd[k].append(f)

## For each (plate,mjd) pair, find the relevant spPlate file and read the data.
print('\ndone')
fl = []
tids = []
plate = []
mjd = []
fibs = []
nread = 0

for p,m in plate_mjd:
    # Find all entries in args.spplates which contain information about this
    # (plate,mjd) pair. If no files are found, or if more than one file is
    # found, print a warning and exit.
    fname = 'spPlate-{}-{}.fits'.format(p,m)
    f = [toto for toto in args.spplates if fname in toto]
    if len(f)==0:
        print('WARNING: file {} not found'.format(fname))
        print('WARNING: args is {} '.format(args.spplates[0]))
        print('WARNING: ignoring file')
        continue
        #sys.exit(1)
    if len(f)>1:
        print('WARNING: multiple files found', f)
        print('WARNING: exiting')
        sys.exit(1)

    # Read the spPlate file found, using the list of relevant fibers from the
    # plate_mjd dictionary.
    f = f[0]
    print('Reading file {}, nread={}, ntot={}'.format(f,nread,len(plate_mjd)))
    nread += 1
    fibers = plate_mjd[(p,m)]

    if args.single_exposures:
        h = fitsio.FITS(f)
        head = h[0].read_header()

        # Choose an exposure number at random from the spPlate file.
        exps = list(set([head[k][:11] for k in head.keys() if 'EXPID' in k]))
        b_exp = np.random.choice([e for e in exps if e[0]=='b'],replace=False)
        r_exp = 'r'+b_exp[1:]

        b_fname = 'spCFrame-{}.fits'.format(b_exp)
        b_spcframe = [toto for toto in args.spcframes if b_fname in toto]
        if len(b_spcframe)==0:
            print('WARNING: spcframe file for exposure {} not found'.format(b_exp))
            print('WARNING: ignoring file')
            continue
            #sys.exit(1)
        if len(b_spcframe)>1:
            print('WARNING: multiple files found for exposure', b_exp)
            print('WARNING: exiting')
            sys.exit(1)
        b_spcframe = b_spcframe[0]

        r_fname = 'spCFrame-{}.fits'.format(r_exp)
        r_spcframe = [toto for toto in args.spcframes if r_fname in toto]
        if len(r_spcframe)==0:
            print('WARNING: spcframe file for exposure {} not found'.format(r_exp))
            print('WARNING: ignoring file')
            continue
            #sys.exit(1)
        if len(r_spcframe)>1:
            print('WARNING: multiple files found for exposure', r_exp)
            print('WARNING: exiting')
            sys.exit(1)
        r_spcframe = r_spcframe[0]

        aux = io.read_spcframe(b_spcframe,r_spcframe,fibers)

    else:
        aux = io.read_spplate(f, fibers)

    if aux is not None:
        tids_plate = [thid_db[(p,m,fib)] for fib in aux[0]]
        tids.append(tids_plate)
        fl.append(aux[1])
        plate.append([p]*len(aux[0]))
        mjd.append([m]*len(aux[0]))
        fibs.append(aux[0])

# Concatenate all results to form single arrays.
tids = np.concatenate(tids)
fl = np.concatenate(fl)
plate = np.concatenate(plate)
mjd = np.concatenate(mjd)
fibs = np.concatenate(fibs)

## Write the output to a fits file, with flux/iv in the primary HDU, and a
## catalog of objects in the 1st extension.
h = fitsio.FITS(args.out,'rw',clobber=True)
h.write(fl)
h.write([tids, plate, mjd, fibs], names=['TARGETID','PLATE','MJD','FIBERID'])
h.close()
